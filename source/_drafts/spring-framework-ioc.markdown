---
layout: post
title: "Spring Framework: IoC"
---

# 控制反转(Inverse of Control, IoC)
控制反转是Spring框架提供的核心功能。控制反转又称做依赖注入(dependency injection, DI)，它实现java项目中各组件的深层次解耦。IoC是一种在深层次考虑组件之间的耦合关系之后提出的一种结偶方法。

我们先考虑考虑组件之间的耦合。在OO模型中，我们为了用类来建模各种各样的对象，常常会用到以下几种常见的方法：

*   继承(inheritance)
*   合成(composition)

先来看看继承。我们通过一个继承一个类，可以在原有代码的基础上，扩展一个类的功能。需要注意的是，相比于合成，继承需要我们更加了解我们所扩展的类的内部结构。在我们深入了解了父类的结构与性质之后，才可以写出正确的代码。

合成是另一种有效的建模手段。有些关系如“一个汽车包含某个零件”这样的关系往往能够用合成建模。合成理论上可以达到与继承一样的效果，在java中，我们继承一个类，实际上扩展了其接口，由于正确的封装，我们往往不需要知道一个类的内部构造，因此，我们可以通过实现相同的接口来完成与继承一样的功能。

于是，对象往往由各种各样的方式组合到一起，共同构成一个系统。为了编写可复用的代码，就一定要实现各个主要组件之间的解耦，否则就会出现迁一发动全身的情况，连维护起来都困难，更不要说复用了。OOP中一个很基本的思想就是面向接口编程。java，c++等语言中OOP的实现是基于消息传递模型的，比如我有一个对象，我可以给这个对象发送一个消息，让他执行某个方法，这是一个很显然的client/server模型。如果我们严格按照一个对象的接口编程，而不去管对象的具体实现，那么就可一写出与对象实现无关的代码，这样实现了调用者与具体实现的解偶，使得我们可以自由更换接口的实现者（对象）。

具体到java语言本身，这样的操作并不容易实现，我们日常中常常会写出这样的代码：

``` java
ImplA a = new ImplA(); 
```
这样做我们的`a`明显是`ImplA`的一个对象，我们基本假定的他的具体实现，现在我们朝着面向接口编程迈一小步：

``` java
InterfaceA a = new ImplA();
```

现在好了，我们在接下来的代码中只能照着`InterfaceA`这个接口编程。但是，其实我们还是知道`a`到底是什么的，这时候又可以继续改进：

``` java
InterfaceA a = SomeA.createSomeA();
```

我们通过一个工厂方法构造对象`a`，这时候我们不知到`a`到底是什么了，同时，构造对象的任务被委托给这个静态工厂方法。但是这样写还有深层次问题没有解决：我们通过面向接口编程实现了调用者与具体实现的解偶，但是却引进了新的耦合，即我们必须知道这个静态工厂方法。也就是说，脱离了`SomeA`这个类我们的代码就会跪，这真是一个悲伤的故事。其实仔细一分析就可以发现问题的源头就是我们在代码中**显式地**构造了对象`a`，如果我们凭空有了一个对象`a`，比如说，作为方法的参数传进来的，那么接下来的代码中就不会有这样的问题。

# 控制反转(IoC) or 依赖注入(DI)
想象一个对象A，对象A内部包含一个对象B和对象C，我们的代码可能是这个样子的：

``` java
public class A {
    private B b;
    private C c;

    public A() {
        this.b = new B();
        this.c = new C();
    }
}

```

对于构造这样的对象A，我们可以写出控制流程：

1.  
2.  将
