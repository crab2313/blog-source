---
title: ARMv8 应用级架构分析
tags: ["ARMv8", "ARM"]
---

# 寄存器模型

从应用程序开发者的角度看，AArch64的寄存器模型相当简单，主要可以分成下面几个部分：

* R0-R30 
* SP
* PC
* V0-V31
* FPCR， FPSR

R0-R30是31个64位寄存器，和x64一样，可以使用特殊的名称（W0-W30）访问R0-R30的下半段。SP明显就是栈寄存器，可以使用WSP访问SP的下半段，而PC是Program Counter。后面的寄存器用做浮点指令集和SIMD指令集的寄存器。

# PSTATE

PSTATE的概念和x64的rflags差不多，也是用于记录处理器处理状态。但是ARM官方文档中并没有称其为寄存器，而是称其为抽象概念。自然，PSTATE肯定有与计算相关的标志位：

* N 如果计算结果所为有符号数时是置一
* Z 如果计算结果为0时置一
* C Carry位，即两个无符号数相加时有溢出的进位
* V 溢出位，这个是指有符号数的溢出

ARM指令集存在比较多的条件指令，如ADD， SUB等常见的算术指令都有其对应的条件指令版本。除此之外，还有四个只能在EL0访问的MASK:

* D Debug exception mask
* A SError interrupt mask
* I IRQ interrupt mask
* F FIQ interrupt mask

# 特权级别

从ARMv8-A的种种设计来看，其整体功能特性开始向amd64架构看齐，同时借鉴了很多x86_64的设计理念。ARMv8-A与amd64一样都保持了对原有架构的兼容性，因此ARMv8处理器可以运行在两种状态下：AArch64和AArch32。AArch32大体上与ARMv7的A32和T32指令相同，而AArch64是基于A32重新设计的一套32位指令集。

ARMv8-A的标准中定义了四个异常等级(Exception Level)，下面都称作EL0～EL3。ARMv8从设计上就规定好了这几个EL等级的用途：

- EL0运行普通应用程序
- EL1运行操作系统
- EL2运行Hypervisor
- EL3运行Secure Monitor，一般为系统级固件

ARMv8的实现必须实现EL0和EL1，而EL2和EL3是可选的。

# 编程环境

## 寄存器

ARMv8提供了31个64位的通用寄存器，称之为R0-R30，每个寄存器可以以32位或64位寄存器的形式访问。32位模式下访问的寄存器是原本寄存器的低32位，以W0-W30命名，需要注意的是，对W0-W30寄存器的写入操作会直接将原寄存器的高32位置0，这一点与x86_64的行为并不一样。64位模式下的寄存器称为X0-X30。注意，这里的通用是指硬件设计上的通用，每个寄存器在ARMv8-A平台ABI都有具体的定义。

除此之外，ARMv8-A还提供了SP和PC两个64位寄存器。SP寄存器是栈指针寄存器，其作用与x86_64上的rsp是一样的，其低32位可以用WSP寄存器访问。PC寄存器即Program Counter，这个寄存器保存当前正在执行的指令的地址。A64采用定长的32位指令，因此ARMv8的硬件本身有提供PC和SP的对齐检查，可以根据需要开启。与x86的eflags一样，ARMv8-A提供了PSTATE寄存器，作为应用程序开发者，只需要关心以下几个标志位：

- N	负数标志，如果把上次的运算结果看做有符号数，该数为负数时将N标志置1
- Z	零标志， 上次指令运行结果为0时置1
- C	进位标志
- V	溢出标志

ARMv8还提供32个128位的寄存器V0-V31作为SIMD指令和浮点指令的目标寄存器。

## 内存模型

与x86一样，ARMv8并不保证对内存的访问顺序与指令执行的顺序一致，处理器可以根据自生需要重新对内存的访问排序，以此提高综合性能。在通过内存地址访问内存时，ARMv8将内存地址分为两类：***普通内存***和***设备内存***。

普通内存是我们最常见到的内存类型，ARMv8处理器在访问这种内存时，不能访问顺序与保证发出内存读写指令的顺序一致。也就是说，ARMv8与x86机构一样，可以通过重新对IO指令进行排序，以此增加流水线的利用效率。

设备内存即使用MMIO形式可以访问的设备寄存器空间，ARMv8显式的区分这种内存，处理器在访问这种类型的内存时，会严格按照指令发出的顺序进行访问。

# Cache

ARMv8-A默认L1和L2是存在处理器中的，L3为外部缓存。ARMv8中，L1缓存分为数据缓存和指令缓存，分别称为L1d和L1i。ARM采用多路缓存的方式减少出现Cache Thrashing的概率。A53处理器使用4路缓存，

# ABI

平台ABI包含很多内容，包括AArch64 ELF文件格式标准，PCS，C库，C++ABI等等，这里重点了解PCS（Procedure）。

## 寄存器调用协定

作为RISC架构的处理器，ARMv8拥有众多通用寄存器，PCS将通用寄存器分配如下：

- X0-X7 作为参数传递时用的寄存器
- X9-X15 作为调用方保存的寄存器
- X19-X29 作为被调用方需要保存的寄存器
- X8 作为保存非直接返回值的指针，例如返回一个结构体
- X18 留作平台ABI自定义用途
- X29 作为栈帧寄存器FP，即与x86上的RBP寄存器一个用途
- X30 是LR寄存器，用于保存函数调用的返回值

## 栈帧结构

AAPCS64中定义栈是向下增长的，调用其他函数时，所需的操作如下：

1. 将需要通过栈传递的参数保存在栈中
2. 调用BL指令进行跳转

BL指令与B指令作用是一样的，只不过执行时会将该指令的后一条指令的返回值保存在LR寄存器中。同样，被调用函数需要做一些必要的事情：

1. 在栈预留好本地变量的位置
2. 将上面提到的被调用函数需要保存的寄存器保存在栈中
3. 将当前的LR和FP保存在栈中（1-3中对栈空间的申请可以通过一次操作完成）
4. 将FP的值设置为SP的值（注意，此时SP指向的地址中的值即为刚刚保存的FP的值）

函数退出时需要还原SP、LR和FP的值。这个调用方式对于习惯x86的人来说是比较奇怪的，这与RISC的特性有关。对于ARMv8架构来说，它的同用寄存器数量很多，所以可以提供一个单独的寄存器保存函数的地址，这与x86不同。***函数必须自己保存LR和FP的值，不然这个函数就无法调用其他的函数***，因为调用其他函数的时候BL指令会破坏原先LR寄存器中的值。这样做从根本上减少了对内存的读写次数，从设计层面提高了性能。

下面举例一个常见的堆栈操作汇编代码：

```asm
STP X29, X30, [SP, #-48]!  # 这里是SP指针减去48（即分配全部的栈空间）,
                           # 并将LR，FP的值保存在SP指向的地址中
MOV X29, SP                # 将X29设置称SP的值
STP X19, X20, [X29, #16]   # 将X19和X20的值保存在栈中对应的位置
......
LDP X19, X20, [X29, #16]   # 还原X19和X20的值
LDP X29, X30, [SP], #48]   # 还原FP和LR的值
```

从另一个角度来看，对于一个被调用的函数来说，可以通过FP寄存器获取通过栈传递近来的参数，而可以通过减小SP的方式申请新的栈空间。FP寄存器指向的内存地址中保存的值永远是FP寄存器原先的值，这是一个链表结构。