---
layout: post
title: "Database System Concept:1 Data Storage and Querying"
---

# 存储与文件结构
*   第一级存储：高速缓存(cache)与主存(main memory)
*   第二级存储：磁盘(magnetic disk)与FLASH
*   第三级存储：光介质存储与磁带存储

我们称第二级存储为上线存储，称第三级存储为离线存储，因为磁盘，FLASH存储是直接接入计算机的存储，而光介质存储及磁带存储，常常用作数据备份。

因为数据库服务器实际上也是一个软件，要跑在操作系统之上，那么自然而然要运行在操作系统提供的框架之下。文件(file)是操作系统对于存储管理的一个抽象，我们需要考虑如何将数据存储在一个文件中。

文件在我们的眼中可以看作一个连续的字节数组，但这只是逻辑上的概念，是操作系统给我们提供好了的抽象。实际上文件并不一定是存储在一块连续的存储器空间上。文件是由一种称为块(block)的逻辑单元组成的，大小一般为4到8KB。实际上一个块是存储在一片连续的存储单元中的，也就是说块实质上是文件的读取与传输单元。

实际上，块作为读写单元，与我们的IO效率紧密相关。我们一般默认任何一条记录(record)所占的空间都比一个块小。也就是说一个块能够存储多条记录，现在我们所面对的问题变成了如何将记录保存在块中。

## 固定长度记录(Fixed-Length Records)
为了保存固定长度的记录，一个显而易见的方法就是把整个块当成一个数组，通过下标寻址，但是这个方法有显而易见的问题：

1.  除非我们的块长度是记录长度的倍数，不然我们肯定会遇到数组越界，亦即一条记录前半部分可以保存在我们的块中，后半部分需要保存在另一个块中
2.  当我们想要删除一个记录时，必须立即将被删除的记录所占的位置填上。我们可以将另一条记录保存在被删除的记录所在的位置上，或者想出一种标记被删除的记录的方式。

对于第一个问题，显然我们不能将一条数据分成两份保存，这样不仅增加了IO开销（读了两个段），而且破坏了第二个段的结构（记录不是从偏移为0开始）。所以，我们将块的尾巴上的这个记录去掉就行了，这样做的代价是浪费了一定量的空间。

第二个问题比较难搞，我们需要权衡许多其他的问题。首先，我们可以将被删除的记录之后的记录整个往上移，填掉被删除记录所占的空位，但是这样做会造成大量的复制，不可取。一个更优的方法是将最后一条记录取出来填掉空位，但是更好的方式是使用一个标识来标明这个记录被删除掉了。仅仅有了这个标识并不够，我们显然必须遍历所有记录才能够找到这个空位，开销不可接受，因此需要另一种机制来让我们快速找到一个空位。我们可以采用链接法，就像一个链表一样，在空位里保存下一个空位的指针，这样就可以快速遍历所有的空位，对空位的操作就像操作链表一样。

## 变长记录(Variable-Length Records)
变长记录的操作显然需要比定长记录考虑得更多。对记录的删除与插入，显然不能像定长记录那么简单。在数据库系统中，我们会在如下问题中遇到变长记录问题：

*   在一个文件中存储不同种类的记录
*   记录中包含有变长的域(field)
*   记录中允许出现重复结构如数组等

显然，我们需要解决如下两个问题：

*   对于一个记录而言，如何有效的从记录中取出某个域
*   对于一个块而言，如何快速的取出某个指定的记录

对于一条变长记录，我们可以将变长的域与定长域区分对待。定长域保存在记录开头，而变长域，我们可以保存一个“元数据”，即（偏移量，长度）这样的元组，这个元组本身是定长的，由此我们可以确定变长域的开头与结尾。我们还可一加入一个bitmap来表示哪个变长域值为`null`。

对于第二个问题，多用分槽页结构(slotted-page structure)来解决。该结构使用一个头部保存下列信息：

1.  记录的总数
2.  未占用空间的末尾
3.  一个内容为每个记录的位置及长度的数组

简单来说，分槽页结构是像“头部|未占用空间|数据区”这样的结构。该结构实现了快速得到块中特定记录。

## 记录在文件中的组织
在讨论了如何表示记录之后，现在我们考虑如何组织记录。下面是常见的几种方式：

*   堆组织:记录完全无序，每种记录都放在一个单独的文件中
*   序列组织：记录按照特定键排序
*   哈希组织：记录经由哈希函数分配到特定的块中

堆组织显然没什么卵用，基本无法想象出任何优点。

## 序列组织方式
序列组织方式是将所有记录按照特定搜索键进行排序。搜索键(search key)可以是表中的一个属性或者多个属性的集合，它并不需要是超键(superkey)。序列组织方式允许我们按照一定顺序读取记录。

然而，删除和插入数据成了问题，我们不可能为了删除或者插入一个记录而去移动一大片记录。解决方案同样是链接法，使用指针将每条记录串起来，如同操作链表一样，在插入数据的时候，先确认是否有空位，如果有，就插入到空位中，如果没有，将数据放到另一个块中，称为溢出块(overflow block)。但是这样做有很严重的问题：碎片化，可能过了一阵子，记录的位置就变得乱七八糟了。所以我们必须定期重组织(reorganization)记录，将其恢复成有序状态。

# 多表聚类文件组织(Multitable clustering file organization)
将多张表使用共同的搜索键排在一起，再使用链接法区分各个表的组织方法。对特定操作有信仰加成。


